
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yourusername/asc/cmd/check.go (10.0%)</option>
				
				<option value="file1">github.com/yourusername/asc/cmd/cleanup.go (17.6%)</option>
				
				<option value="file2">github.com/yourusername/asc/cmd/doctor.go (10.8%)</option>
				
				<option value="file3">github.com/yourusername/asc/cmd/down.go (4.3%)</option>
				
				<option value="file4">github.com/yourusername/asc/cmd/init.go (11.4%)</option>
				
				<option value="file5">github.com/yourusername/asc/cmd/root.go (25.0%)</option>
				
				<option value="file6">github.com/yourusername/asc/cmd/secrets.go (38.4%)</option>
				
				<option value="file7">github.com/yourusername/asc/cmd/services.go (4.7%)</option>
				
				<option value="file8">github.com/yourusername/asc/cmd/test.go (0.9%)</option>
				
				<option value="file9">github.com/yourusername/asc/cmd/up.go (1.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/yourusername/asc/internal/check"
)

// osExit is a variable that can be mocked in tests
var osExit = os.Exit

var checkCmd = &amp;cobra.Command{
        Use:   "check",
        Short: "Verify environment setup and dependencies",
        Long: `Verify that all required dependencies are installed and properly configured.
This includes checking for required binaries (git, python3, uv, bd), 
validating the asc.toml configuration file, and verifying API keys in .env file.`,
        Run: runCheck,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(checkCmd)
}</span>

func runCheck(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Default paths
        configPath := "asc.toml"
        envPath := ".env"

        // Create checker instance
        checker := check.NewChecker(configPath, envPath)

        // Run all checks
        results := checker.RunAll()

        // Format and print results
        output := check.FormatResults(results)
        fmt.Println(output)

        // Exit with appropriate status code
        if check.HasFailures(results) </span><span class="cov0" title="0">{
                osExit(1)
        }</span>
        <span class="cov0" title="0">osExit(0)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/spf13/cobra"
        "github.com/yourusername/asc/internal/logger"
)

var (
        cleanupDays int
        cleanupDryRun bool
)

var cleanupCmd = &amp;cobra.Command{
        Use:   "cleanup",
        Short: "Clean up old log files",
        Long: `Remove log files older than the specified number of days.
This helps manage disk space by removing old logs that are no longer needed.

By default, logs older than 30 days are removed.`,
        Run: runCleanup,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(cleanupCmd)
        cleanupCmd.Flags().IntVar(&amp;cleanupDays, "days", 30, "Remove logs older than this many days")
        cleanupCmd.Flags().BoolVar(&amp;cleanupDryRun, "dry-run", false, "Show what would be deleted without actually deleting")
}</span>

func runCleanup(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to get home directory: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logsDir := filepath.Join(homeDir, ".asc", "logs")

        if cleanupDryRun </span><span class="cov0" title="0">{
                fmt.Printf("Dry run: would remove logs older than %d days from %s\n", cleanupDays, logsDir)
                // TODO: Implement dry run listing
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Cleaning up logs older than %d days from %s...\n", cleanupDays, logsDir)

        maxAge := time.Duration(cleanupDays) * 24 * time.Hour
        if err := logger.CleanupOldLogs(logsDir, maxAge); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to cleanup logs: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("✓ Log cleanup completed")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/yourusername/asc/internal/doctor"
        "github.com/yourusername/asc/internal/logger"
)

var (
        doctorFix    bool
        doctorVerbose bool
        doctorJSON   bool
)

var doctorCmd = &amp;cobra.Command{
        Use:   "doctor",
        Short: "Diagnose and fix common issues with the agent stack",
        Long: `Run comprehensive diagnostics on the agent stack to detect and fix common issues.

The doctor command checks for:
- Configuration problems
- Corrupted state (PIDs, logs)
- Permission issues
- Resource problems
- Network connectivity
- Agent health issues

Use --fix to automatically remediate detected issues where possible.`,
        Run: runDoctor,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(doctorCmd)
        
        doctorCmd.Flags().BoolVar(&amp;doctorFix, "fix", false, "Automatically fix issues where possible")
        doctorCmd.Flags().BoolVar(&amp;doctorVerbose, "verbose", false, "Show detailed diagnostic information")
        doctorCmd.Flags().BoolVar(&amp;doctorJSON, "json", false, "Output results in JSON format")
}</span>

func runDoctor(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        logger.Info("Running asc doctor diagnostics...")
        
        // Default paths
        configPath := "asc.toml"
        envPath := ".env"
        
        // Create doctor instance
        doc, err := doctor.NewDoctor(configPath, envPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize doctor: %v", err)
                fmt.Fprintf(os.Stderr, "Error: Failed to initialize doctor: %v\n", err)
                osExit(1)
        }</span>
        
        // Run diagnostics
        <span class="cov0" title="0">report, err := doc.RunDiagnostics()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to run diagnostics: %v", err)
                fmt.Fprintf(os.Stderr, "Error: Failed to run diagnostics: %v\n", err)
                osExit(1)
        }</span>
        
        // Apply fixes if requested
        <span class="cov0" title="0">if doctorFix </span><span class="cov0" title="0">{
                logger.Info("Applying automatic fixes...")
                fixReport, err := doc.ApplyFixes(report)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to apply fixes: %v", err)
                        fmt.Fprintf(os.Stderr, "Error: Failed to apply fixes: %v\n", err)
                        osExit(1)
                }</span>
                <span class="cov0" title="0">report.FixesApplied = fixReport</span>
        }
        
        // Output results
        <span class="cov0" title="0">if doctorJSON </span><span class="cov0" title="0">{
                output, err := report.ToJSON()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to format JSON output: %v", err)
                        fmt.Fprintf(os.Stderr, "Error: Failed to format JSON output: %v\n", err)
                        osExit(1)
                }</span>
                <span class="cov0" title="0">fmt.Println(output)</span>
        } else<span class="cov0" title="0"> {
                output := report.Format(doctorVerbose)
                fmt.Println(output)
        }</span>
        
        // Exit with appropriate code
        <span class="cov0" title="0">if report.HasCriticalIssues() </span><span class="cov0" title="0">{
                osExit(1)
        }</span>
        <span class="cov0" title="0">osExit(0)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
        "github.com/yourusername/asc/internal/process"
)

var downCmd = &amp;cobra.Command{
        Use:   "down",
        Short: "Gracefully shut down all agents and services",
        Long: `Stop the agent stack by:
- Stopping all agent processes
- Stopping the mcp_agent_mail service
- Cleaning up PID files
- Reporting shutdown status`,
        Run: runDown,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(downCmd)
}</span>

func runDown(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Initialize process manager with ~/.asc/pids and ~/.asc/logs
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to get home directory: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">pidsDir := filepath.Join(homeDir, ".asc", "pids")
        logsDir := filepath.Join(homeDir, ".asc", "logs")

        procManager, err := process.NewManager(pidsDir, logsDir)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to initialize process manager: %v\n", err)
                os.Exit(1)
        }</span>

        // List all managed processes
        <span class="cov0" title="0">processes, err := procManager.ListProcesses()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to list processes: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(processes) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No running processes found")
                fmt.Println("Agent stack is offline")
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Shutting down %d process(es)...\n", len(processes))

        // Stop all processes using process manager
        // This will handle both agents and mcp_agent_mail service
        if err := procManager.StopAll(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Warning: Some processes failed to stop cleanly: %v\n", err)
                // Continue anyway to print confirmation
        }</span>

        // Print confirmation message
        <span class="cov0" title="0">fmt.Println("Agent stack is offline")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
        "github.com/yourusername/asc/internal/config"
        "github.com/yourusername/asc/internal/tui"
)

var (
        templateFlag string
        listTemplatesFlag bool
        saveTemplateFlag string
)

var initCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize asc with interactive setup wizard",
        Long: `Launch an interactive setup wizard that guides you through:
- Checking for required dependencies
- Installing missing components
- Configuring API keys
- Generating default configuration files
- Validating the setup

Templates:
  --template=solo   Single agent for individual development
  --template=team   Planner, coder, and tester agents
  --template=swarm  Multiple agents per phase for parallel work`,
        Run: runInit,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(initCmd)
        initCmd.Flags().StringVar(&amp;templateFlag, "template", "", "Use a predefined template (solo, team, swarm)")
        initCmd.Flags().BoolVar(&amp;listTemplatesFlag, "list-templates", false, "List all available templates")
        initCmd.Flags().StringVar(&amp;saveTemplateFlag, "save-template", "", "Save current config as a custom template")
}</span>

func runInit(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Handle --list-templates flag
        if listTemplatesFlag </span><span class="cov0" title="0">{
                listTemplates(cmd)
                return
        }</span>

        // Handle --save-template flag
        <span class="cov0" title="0">if saveTemplateFlag != "" </span><span class="cov0" title="0">{
                saveTemplate(cmd)
                return
        }</span>

        // Launch the interactive setup wizard with optional template
        <span class="cov0" title="0">wizard := tui.NewWizard()
        if templateFlag != "" </span><span class="cov0" title="0">{
                wizard.SetTemplate(templateFlag)
        }</span>
        <span class="cov0" title="0">if err := wizard.Run(); err != nil </span><span class="cov0" title="0">{
                cmd.PrintErrf("Error running setup wizard: %v\n", err)
                return
        }</span>
}

func listTemplates(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.Println("Available templates:")
        cmd.Println()

        // List built-in templates
        cmd.Println("Built-in templates:")
        for _, tmpl := range config.ListTemplates() </span><span class="cov0" title="0">{
                cmd.Printf("  %s - %s\n", tmpl.Name, tmpl.Description)
        }</span>

        // List custom templates
        <span class="cov0" title="0">customTemplates, err := config.ListCustomTemplates()
        if err != nil </span><span class="cov0" title="0">{
                cmd.PrintErrf("Warning: Failed to load custom templates: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">if len(customTemplates) &gt; 0 </span><span class="cov0" title="0">{
                cmd.Println()
                cmd.Println("Custom templates:")
                for _, tmpl := range customTemplates </span><span class="cov0" title="0">{
                        cmd.Printf("  %s - %s\n", tmpl.Name, tmpl.Description)
                }</span>
        }
}

func saveTemplate(cmd *cobra.Command) <span class="cov0" title="0">{
        configPath := config.DefaultConfigPath()
        if err := config.SaveCustomTemplate(configPath, saveTemplateFlag); err != nil </span><span class="cov0" title="0">{
                cmd.PrintErrf("Error saving template: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">cmd.Printf("Template '%s' saved successfully\n", saveTemplateFlag)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
        _ "github.com/spf13/viper"
        _ "github.com/charmbracelet/bubbletea"
        _ "github.com/charmbracelet/lipgloss"
        _ "github.com/charmbracelet/bubbles"
        "github.com/yourusername/asc/internal/logger"
)

var (
        verbose bool
)

var rootCmd = &amp;cobra.Command{
        Use:   "asc",
        Short: "Agent Stack Controller - Orchestrate your AI coding agent colony",
        Long: `asc is a command-line orchestration tool that manages a local colony of AI coding agents.
It provides developers with a mission control interface for starting, monitoring, and 
coordinating headless background agents that work collaboratively on software development tasks.`,
        PersistentPreRun: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        logger.SetLevel(logger.DEBUG)
                }</span>
        },
}

// Execute runs the root command
func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov8" title="1">{
        // Global flags
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Enable verbose logging (debug level)")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/yourusername/asc/internal/secrets"
)

var secretsCmd = &amp;cobra.Command{
        Use:   "secrets",
        Short: "Manage encrypted secrets using age",
        Long: `Securely manage API keys and secrets using age encryption.

Age (https://github.com/FiloSottile/age) provides simple, secure file encryption.
This command helps you encrypt your .env file so you can safely commit it to git.

Workflow:
  1. asc secrets init          # Generate age key
  2. Create .env with your API keys
  3. asc secrets encrypt        # Encrypt .env → .env.age
  4. git add .env.age           # Commit encrypted file
  5. asc secrets decrypt        # Decrypt when needed

The age key is stored in ~/.asc/age.key and should NEVER be committed to git.`,
}

var secretsInitCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize age encryption (generate key)",
        Long: `Generate a new age encryption key for secrets management.

The key will be stored in ~/.asc/age.key with restrictive permissions (0600).
This key is used to encrypt and decrypt your .env files.

IMPORTANT: Keep this key safe and NEVER commit it to git!`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                manager := secrets.NewManager()

                if manager.KeyExists() </span><span class="cov0" title="0">{
                        fmt.Println("⚠ Age key already exists at", manager.GetKeyPath())
                        fmt.Print("Do you want to overwrite it? (y/N): ")
                        var response string
                        fmt.Scanln(&amp;response)
                        if response != "y" &amp;&amp; response != "Y" </span><span class="cov0" title="0">{
                                fmt.Println("Aborted.")
                                return nil
                        }</span>
                }

                <span class="cov8" title="1">if !manager.IsAgeInstalled() </span><span class="cov8" title="1">{
                        fmt.Println("✗ age is not installed")
                        fmt.Println("\nInstall age:")
                        fmt.Println("  macOS:   brew install age")
                        fmt.Println("  Linux:   apt install age  (or download from https://github.com/FiloSottile/age)")
                        fmt.Println("  Windows: scoop install age")
                        return fmt.Errorf("age not installed")
                }</span>

                <span class="cov0" title="0">fmt.Println("Generating age key...")
                if err := manager.GenerateKey(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate key: %w", err)
                }</span>

                <span class="cov0" title="0">pubKey, err := manager.GetPublicKey()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get public key: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Println("✓ Age key generated successfully")
                fmt.Println("\nKey location:", manager.GetKeyPath())
                fmt.Println("Public key:", pubKey)
                fmt.Println("\n⚠ IMPORTANT: Keep your key safe and NEVER commit it to git!")
                fmt.Println("✓ The key file has been set to permissions 0600")

                return nil</span>
        },
}

var secretsEncryptCmd = &amp;cobra.Command{
        Use:   "encrypt [file]",
        Short: "Encrypt secrets file (default: .env)",
        Long: `Encrypt your secrets file using age encryption.

By default, encrypts .env to .env.age. You can specify a different file.

The encrypted .env.age file is safe to commit to git, while .env should
be added to .gitignore.

Example:
  asc secrets encrypt           # Encrypts .env → .env.age
  asc secrets encrypt .env.prod # Encrypts .env.prod → .env.prod.age`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                manager := secrets.NewManager()

                if !manager.IsAgeInstalled() </span><span class="cov8" title="1">{
                        return fmt.Errorf("age is not installed. Run 'asc secrets init' for installation instructions")
                }</span>

                <span class="cov0" title="0">if !manager.KeyExists() </span><span class="cov0" title="0">{
                        return fmt.Errorf("age key not found. Run 'asc secrets init' first")
                }</span>

                <span class="cov0" title="0">envPath := ".env"
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        envPath = args[0]
                }</span>

                // Check if file exists
                <span class="cov0" title="0">if _, err := os.Stat(envPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("file %s not found", envPath)
                }</span>

                // Validate env file structure
                <span class="cov0" title="0">if err := manager.ValidateEnvFile(envPath); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠ Warning: %v\n", err)
                        fmt.Print("Continue anyway? (y/N): ")
                        var response string
                        fmt.Scanln(&amp;response)
                        if response != "y" &amp;&amp; response != "Y" </span><span class="cov0" title="0">{
                                fmt.Println("Aborted.")
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("Encrypting %s...\n", envPath)
                if err := manager.EncryptEnv(envPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("encryption failed: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

var secretsDecryptCmd = &amp;cobra.Command{
        Use:   "decrypt [file]",
        Short: "Decrypt secrets file (default: .env.age)",
        Long: `Decrypt your encrypted secrets file using age decryption.

By default, decrypts .env.age to .env. You can specify a different file.

The decrypted file will have restrictive permissions (0600) set automatically.

Example:
  asc secrets decrypt           # Decrypts .env.age → .env
  asc secrets decrypt .env.prod # Decrypts .env.prod.age → .env.prod`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                manager := secrets.NewManager()

                if !manager.IsAgeInstalled() </span><span class="cov8" title="1">{
                        return fmt.Errorf("age is not installed. Run 'asc secrets init' for installation instructions")
                }</span>

                <span class="cov0" title="0">if !manager.KeyExists() </span><span class="cov0" title="0">{
                        return fmt.Errorf("age key not found at %s", manager.GetKeyPath())
                }</span>

                <span class="cov0" title="0">envPath := ".env"
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        envPath = args[0]
                }</span>

                <span class="cov0" title="0">fmt.Printf("Decrypting %s.age...\n", envPath)
                if err := manager.DecryptEnv(envPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("decryption failed: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

var secretsStatusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Show secrets management status",
        Long:  `Display the current status of secrets management including key location and encrypted files.`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                manager := secrets.NewManager()

                fmt.Println("Secrets Management Status")
                fmt.Println("========================")
                fmt.Println()

                // Check age installation
                if manager.IsAgeInstalled() </span><span class="cov0" title="0">{
                        fmt.Println("✓ age is installed")
                }</span> else<span class="cov8" title="1"> {
                        fmt.Println("✗ age is NOT installed")
                        fmt.Println("  Install: brew install age (macOS) or see https://github.com/FiloSottile/age")
                }</span>

                // Check key
                <span class="cov8" title="1">if manager.KeyExists() </span><span class="cov0" title="0">{
                        fmt.Println("✓ Age key exists at", manager.GetKeyPath())
                        if pubKey, err := manager.GetPublicKey(); err == nil </span><span class="cov0" title="0">{
                                fmt.Println("  Public key:", pubKey)
                        }</span>
                } else<span class="cov8" title="1"> {
                        fmt.Println("✗ Age key NOT found")
                        fmt.Println("  Run: asc secrets init")
                }</span>

                <span class="cov8" title="1">fmt.Println()

                // Check for encrypted files
                encryptedFiles := []string{".env.age", ".env.prod.age", ".env.staging.age"}
                fmt.Println("Encrypted Files:")
                foundAny := false
                for _, file := range encryptedFiles </span><span class="cov8" title="1">{
                        if _, err := os.Stat(file); err == nil </span><span class="cov0" title="0">{
                                fmt.Println("  ✓", file)
                                foundAny = true
                        }</span>
                }
                <span class="cov8" title="1">if !foundAny </span><span class="cov8" title="1">{
                        fmt.Println("  (none found)")
                }</span>

                <span class="cov8" title="1">fmt.Println()

                // Check for unencrypted files
                unencryptedFiles := []string{".env", ".env.prod", ".env.staging"}
                fmt.Println("Unencrypted Files:")
                foundAny = false
                for _, file := range unencryptedFiles </span><span class="cov8" title="1">{
                        if _, err := os.Stat(file); err == nil </span><span class="cov0" title="0">{
                                fmt.Println("  ⚠", file, "(should be encrypted and gitignored)")
                                foundAny = true
                        }</span>
                }
                <span class="cov8" title="1">if !foundAny </span><span class="cov8" title="1">{
                        fmt.Println("  (none found)")
                }</span>

                <span class="cov8" title="1">return nil</span>
        },
}

var secretsRotateCmd = &amp;cobra.Command{
        Use:   "rotate",
        Short: "Rotate age key and re-encrypt all files",
        Long: `Generate a new age key and re-encrypt all encrypted files.

This is useful if you suspect your key has been compromised or as part
of regular security maintenance.

The old key will be backed up to ~/.asc/age.key.old`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                manager := secrets.NewManager()

                if !manager.IsAgeInstalled() </span><span class="cov0" title="0">{
                        return fmt.Errorf("age is not installed")
                }</span>

                <span class="cov0" title="0">if !manager.KeyExists() </span><span class="cov0" title="0">{
                        return fmt.Errorf("no existing key to rotate")
                }</span>

                <span class="cov0" title="0">fmt.Println("⚠ This will generate a new key and re-encrypt all files")
                fmt.Print("Continue? (y/N): ")
                var response string
                fmt.Scanln(&amp;response)
                if response != "y" &amp;&amp; response != "Y" </span><span class="cov0" title="0">{
                        fmt.Println("Aborted.")
                        return nil
                }</span>

                // Find encrypted files
                <span class="cov0" title="0">encryptedFiles := []string{}
                candidates := []string{".env.age", ".env.prod.age", ".env.staging.age"}
                for _, file := range candidates </span><span class="cov0" title="0">{
                        if _, err := os.Stat(file); err == nil </span><span class="cov0" title="0">{
                                encryptedFiles = append(encryptedFiles, file)
                        }</span>
                }

                <span class="cov0" title="0">if len(encryptedFiles) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No encrypted files found to re-encrypt")
                }</span>

                <span class="cov0" title="0">if err := manager.RotateKey(encryptedFiles); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("key rotation failed: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(secretsCmd)
        secretsCmd.AddCommand(secretsInitCmd)
        secretsCmd.AddCommand(secretsEncryptCmd)
        secretsCmd.AddCommand(secretsDecryptCmd)
        secretsCmd.AddCommand(secretsStatusCmd)
        secretsCmd.AddCommand(secretsRotateCmd)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yourusername/asc/internal/config"
        "github.com/yourusername/asc/internal/process"
)

// osExit is a variable that can be mocked in tests (shared with other cmd files)
// var osExit = os.Exit is defined in check.go

var servicesCmd = &amp;cobra.Command{
        Use:   "services",
        Short: "Manage long-running services",
        Long: `Manage long-running services like mcp_agent_mail independently from agents.
This allows you to control the communication server without affecting agent processes.`,
}

var servicesStartCmd = &amp;cobra.Command{
        Use:   "start",
        Short: "Start the mcp_agent_mail service",
        Long:  `Start the mcp_agent_mail server as a background process.`,
        Run:   runServicesStart,
}

var servicesStopCmd = &amp;cobra.Command{
        Use:   "stop",
        Short: "Stop the mcp_agent_mail service",
        Long:  `Terminate the mcp_agent_mail server process.`,
        Run:   runServicesStop,
}

var servicesStatusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Check if the mcp_agent_mail service is running",
        Long:  `Report whether the mcp_agent_mail server is currently running.`,
        Run:   runServicesStatus,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(servicesCmd)
        servicesCmd.AddCommand(servicesStartCmd)
        servicesCmd.AddCommand(servicesStopCmd)
        servicesCmd.AddCommand(servicesStatusCmd)
}</span>

// getProcessManager creates a process manager instance with default directories
func getProcessManager() (*process.Manager, error) <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov0" title="0">pidDir := filepath.Join(homeDir, ".asc", "pids")
        logDir := filepath.Join(homeDir, ".asc", "logs")

        return process.NewManager(pidDir, logDir)</span>
}

// runServicesStart starts the mcp_agent_mail service
func runServicesStart(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load(config.DefaultConfigPath())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to load configuration: %v\n", err)
                osExit(1)
                return
        }</span>

        // Create process manager
        <span class="cov0" title="0">pm, err := getProcessManager()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to create process manager: %v\n", err)
                osExit(1)
                return
        }</span>

        // Check if service is already running
        <span class="cov0" title="0">info, err := pm.GetProcessInfo("mcp_agent_mail")
        if err == nil &amp;&amp; pm.IsRunning(info.PID) </span><span class="cov0" title="0">{
                fmt.Printf("mcp_agent_mail is already running (PID %d)\n", info.PID)
                osExit(0)
                return
        }</span>

        // Parse the start command
        <span class="cov0" title="0">cmdParts := strings.Fields(cfg.Services.MCPAgentMail.StartCommand)
        if len(cmdParts) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Invalid start command in configuration\n")
                osExit(1)
                return
        }</span>

        <span class="cov0" title="0">command := cmdParts[0]
        cmdArgs := cmdParts[1:]

        // Start the service
        pid, err := pm.Start("mcp_agent_mail", command, cmdArgs, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to start mcp_agent_mail: %v\n", err)
                osExit(1)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("✓ mcp_agent_mail started (PID %d)\n", pid)
        fmt.Printf("  URL: %s\n", cfg.Services.MCPAgentMail.URL)
        
        homeDir, _ := os.UserHomeDir()
        logPath := filepath.Join(homeDir, ".asc", "logs", "mcp_agent_mail.log")
        fmt.Printf("  Log: %s\n", logPath)</span>
}

// runServicesStop stops the mcp_agent_mail service
func runServicesStop(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Create process manager
        pm, err := getProcessManager()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to create process manager: %v\n", err)
                osExit(1)
                return
        }</span>

        // Get process info
        <span class="cov0" title="0">info, err := pm.GetProcessInfo("mcp_agent_mail")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: mcp_agent_mail is not running\n")
                osExit(1)
                return
        }</span>

        // Check if process is actually running
        <span class="cov0" title="0">if !pm.IsRunning(info.PID) </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: mcp_agent_mail is not running (stale PID file)\n")
                // Clean up stale PID file
                homeDir, _ := os.UserHomeDir()
                pidFile := filepath.Join(homeDir, ".asc", "pids", "mcp_agent_mail.json")
                os.Remove(pidFile)
                osExit(1)
                return
        }</span>

        // Stop the service
        <span class="cov0" title="0">fmt.Printf("Stopping mcp_agent_mail (PID %d)...\n", info.PID)
        if err := pm.Stop(info.PID); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to stop mcp_agent_mail: %v\n", err)
                osExit(1)
                return
        }</span>

        // Clean up PID file
        <span class="cov0" title="0">homeDir, _ := os.UserHomeDir()
        pidFile := filepath.Join(homeDir, ".asc", "pids", "mcp_agent_mail.json")
        os.Remove(pidFile)

        fmt.Println("✓ mcp_agent_mail stopped")</span>
}

// runServicesStatus checks if the mcp_agent_mail service is running
func runServicesStatus(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Create process manager
        pm, err := getProcessManager()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to create process manager: %v\n", err)
                osExit(1)
                return
        }</span>

        // Get process info
        <span class="cov0" title="0">info, err := pm.GetProcessInfo("mcp_agent_mail")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("mcp_agent_mail: ○ stopped")
                osExit(0)
                return
        }</span>

        // Check if process is running
        <span class="cov0" title="0">if pm.IsRunning(info.PID) </span><span class="cov0" title="0">{
                fmt.Printf("mcp_agent_mail: ● running (PID %d)\n", info.PID)
                fmt.Printf("  Started: %s\n", info.StartedAt.Format("2006-01-02 15:04:05"))
                fmt.Printf("  Log: %s\n", info.LogFile)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("mcp_agent_mail: ○ stopped (stale PID file)")
                // Clean up stale PID file
                homeDir, _ := os.UserHomeDir()
                pidFile := filepath.Join(homeDir, ".asc", "pids", "mcp_agent_mail.json")
                os.Remove(pidFile)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "fmt"
        "os"
        "time"

        "github.com/spf13/cobra"
        "github.com/yourusername/asc/internal/beads"
        "github.com/yourusername/asc/internal/config"
        "github.com/yourusername/asc/internal/mcp"
)

var testCmd = &amp;cobra.Command{
        Use:   "test",
        Short: "Run an end-to-end test of the agent stack",
        Long: `Run an end-to-end test to verify all components are communicating correctly.
This creates a test task in beads, sends a test message to mcp_agent_mail,
and verifies that both systems are responding properly.`,
        Run: runTest,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(testCmd)
}</span>

// runTest executes the end-to-end test flow
func runTest(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        fmt.Println("Running agent stack test...")
        fmt.Println()

        // Load configuration
        cfg, err := config.Load(config.DefaultConfigPath())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Failed to load configuration: %v\n", err)
                fmt.Fprintf(os.Stderr, "Solution: Ensure asc.toml exists and is valid\n")
                os.Exit(1)
        }</span>

        // Initialize clients
        <span class="cov0" title="0">beadsClient := beads.NewClient(cfg.Core.BeadsDBPath, 5*time.Second)
        mcpClient := mcp.NewHTTPClient(cfg.Services.MCPAgentMail.URL)

        // Test 1: Create test beads task
        fmt.Print("1. Creating test beads task... ")
        testTask, err := beadsClient.CreateTask("asc test task")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("✗ FAILED")
                fmt.Fprintf(os.Stderr, "   Error: %v\n", err)
                fmt.Fprintf(os.Stderr, "   Solution: Ensure 'bd' CLI is installed and beads_db_path is correct\n")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Printf("✓ OK (ID: %s)\n", testTask.ID)

        // Test 2: Send test message to MCP server
        fmt.Print("2. Sending test message to MCP server... ")
        testMessage := mcp.Message{
                Timestamp: time.Now(),
                Type:      mcp.TypeMessage,
                Source:    "asc-test",
                Content:   "Test message from asc test command",
        }
        err = mcpClient.SendMessage(testMessage)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("✗ FAILED")
                fmt.Fprintf(os.Stderr, "   Error: %v\n", err)
                fmt.Fprintf(os.Stderr, "   Solution: Ensure mcp_agent_mail server is running (try 'asc services start')\n")
                
                // Clean up test task before exiting
                fmt.Print("   Cleaning up test task... ")
                if cleanupErr := beadsClient.DeleteTask(testTask.ID); cleanupErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("✗ (failed: %v)\n", cleanupErr)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✓")
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
        <span class="cov0" title="0">fmt.Println("✓ OK")

        // Test 3: Poll beads to confirm task exists
        fmt.Print("3. Verifying beads task retrieval... ")
        success := false
        timeout := 30 * time.Second
        pollInterval := 1 * time.Second
        deadline := time.Now().Add(timeout)

        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                tasks, err := beadsClient.GetTasks([]string{"open", "in_progress", "done"})
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("✗ FAILED")
                        fmt.Fprintf(os.Stderr, "   Error: %v\n", err)
                        
                        // Clean up test task before exiting
                        fmt.Print("   Cleaning up test task... ")
                        if cleanupErr := beadsClient.DeleteTask(testTask.ID); cleanupErr != nil </span><span class="cov0" title="0">{
                                fmt.Printf("✗ (failed: %v)\n", cleanupErr)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("✓")
                        }</span>
                        <span class="cov0" title="0">os.Exit(1)</span>
                }

                // Check if our test task is in the list
                <span class="cov0" title="0">for _, task := range tasks </span><span class="cov0" title="0">{
                        if task.ID == testTask.ID </span><span class="cov0" title="0">{
                                success = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if success </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">time.Sleep(pollInterval)</span>
        }

        <span class="cov0" title="0">if !success </span><span class="cov0" title="0">{
                fmt.Println("✗ FAILED (timeout)")
                fmt.Fprintf(os.Stderr, "   Error: Test task not found in beads database after %v\n", timeout)
                
                // Clean up test task before exiting
                fmt.Print("   Cleaning up test task... ")
                if cleanupErr := beadsClient.DeleteTask(testTask.ID); cleanupErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("✗ (failed: %v)\n", cleanupErr)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✓")
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
        <span class="cov0" title="0">fmt.Println("✓ OK")

        // Test 4: Poll MCP to confirm message was received
        fmt.Print("4. Verifying MCP message retrieval... ")
        success = false
        deadline = time.Now().Add(timeout)
        messageCheckTime := testMessage.Timestamp.Add(-1 * time.Second) // Check slightly before to ensure we catch it

        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                messages, err := mcpClient.GetMessages(messageCheckTime)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("✗ FAILED")
                        fmt.Fprintf(os.Stderr, "   Error: %v\n", err)
                        
                        // Clean up test artifacts before exiting
                        fmt.Print("   Cleaning up test task... ")
                        if cleanupErr := beadsClient.DeleteTask(testTask.ID); cleanupErr != nil </span><span class="cov0" title="0">{
                                fmt.Printf("✗ (failed: %v)\n", cleanupErr)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("✓")
                        }</span>
                        <span class="cov0" title="0">os.Exit(1)</span>
                }

                // Check if our test message is in the list
                <span class="cov0" title="0">for _, msg := range messages </span><span class="cov0" title="0">{
                        if msg.Source == "asc-test" &amp;&amp; msg.Type == mcp.TypeMessage </span><span class="cov0" title="0">{
                                success = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if success </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">time.Sleep(pollInterval)</span>
        }

        <span class="cov0" title="0">if !success </span><span class="cov0" title="0">{
                fmt.Println("✗ FAILED (timeout)")
                fmt.Fprintf(os.Stderr, "   Error: Test message not found in MCP server after %v\n", timeout)
                
                // Clean up test task before exiting
                fmt.Print("   Cleaning up test task... ")
                if cleanupErr := beadsClient.DeleteTask(testTask.ID); cleanupErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("✗ (failed: %v)\n", cleanupErr)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✓")
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
        <span class="cov0" title="0">fmt.Println("✓ OK")

        // Test 5: Clean up test artifacts
        fmt.Print("5. Cleaning up test artifacts... ")
        
        // Delete test task
        if err := beadsClient.DeleteTask(testTask.ID); err != nil </span><span class="cov0" title="0">{
                fmt.Println("✗ FAILED")
                fmt.Fprintf(os.Stderr, "   Error: Failed to delete test task: %v\n", err)
                fmt.Fprintf(os.Stderr, "   Note: You may need to manually delete task '%s'\n", testTask.ID)
                os.Exit(1)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("✓ OK")

        // All tests passed
        fmt.Println()
        fmt.Println("✓ Stack is healthy")
        fmt.Println()
        fmt.Println("All components are communicating correctly:")
        fmt.Println("  • beads task database is accessible")
        fmt.Println("  • mcp_agent_mail server is responding")
        fmt.Println("  • Message passing is working")
        
        os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/spf13/cobra"

        "github.com/yourusername/asc/internal/beads"
        "github.com/yourusername/asc/internal/check"
        "github.com/yourusername/asc/internal/config"
        "github.com/yourusername/asc/internal/logger"
        "github.com/yourusername/asc/internal/mcp"
        "github.com/yourusername/asc/internal/process"
        "github.com/yourusername/asc/internal/secrets"
        "github.com/yourusername/asc/internal/tui"
)

var (
        debugMode bool
)

var upCmd = &amp;cobra.Command{
        Use:   "up",
        Short: "Start all agents and services with TUI dashboard",
        Long: `Start the agent stack by:
- Running dependency checks
- Starting the mcp_agent_mail service
- Launching all configured agents
- Opening the TUI dashboard for monitoring`,
        Run: runUp,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(upCmd)
        upCmd.Flags().BoolVar(&amp;debugMode, "debug", false, "Enable debug mode with verbose output")
}</span>

func runUp(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Initialize logger
        if err := logger.Init(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer logger.Close()

        // Enable debug mode if flag is set
        if debugMode </span><span class="cov0" title="0">{
                logger.SetLevel(logger.DEBUG)
                logger.SetFormat(logger.FormatJSON)
                logger.Info("Debug mode enabled")
        }</span>

        // Default paths
        <span class="cov0" title="0">configPath := "asc.toml"
        envPath := ".env"

        logger.Debug("Starting asc up command with config=%s, env=%s", configPath, envPath)

        // Step 0: Auto-decrypt secrets if needed
        if _, err := os.Stat(envPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Check if encrypted version exists
                if _, err := os.Stat(envPath + ".age"); err == nil </span><span class="cov0" title="0">{
                        fmt.Println("🔐 Decrypting secrets...")
                        logger.Debug("Decrypting secrets from %s.age", envPath)
                        secretsManager := secrets.NewManager()
                        if err := secretsManager.DecryptEnv(envPath); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to decrypt secrets: %v", err)
                                fmt.Fprintf(os.Stderr, "Failed to decrypt secrets: %v\n", err)
                                fmt.Fprintln(os.Stderr, "Run 'asc secrets decrypt' manually or 'asc init' to set up encryption.")
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">fmt.Println("✓ Secrets decrypted")
                        logger.Debug("Secrets decrypted successfully")</span>
                }
        }

        // Step 1: Run silent dependency check
        <span class="cov0" title="0">logger.Debug("Running dependency checks")
        checker := check.NewChecker(configPath, envPath)
        results := checker.RunAll()

        if debugMode </span><span class="cov0" title="0">{
                for _, result := range results </span><span class="cov0" title="0">{
                        logger.WithFields(logger.Fields{
                                "check":  result.Name,
                                "status": result.Status,
                        }).Debug("Dependency check result: %s", result.Message)
                }</span>
        }

        <span class="cov0" title="0">if check.HasFailures(results) </span><span class="cov0" title="0">{
                logger.Error("Dependency check failed")
                fmt.Fprintln(os.Stderr, "Dependency check failed. Run 'asc check' for details.")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Debug("All dependency checks passed")

        // Step 2: Load configuration from asc.toml
        logger.Debug("Loading configuration from %s", configPath)
        cfg, err := config.Load(configPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to load configuration: %v", err)
                fmt.Fprintf(os.Stderr, "Failed to load configuration: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if debugMode </span><span class="cov0" title="0">{
                logger.WithFields(logger.Fields{
                        "agents":   len(cfg.Agents),
                        "mcp_url":  cfg.Services.MCPAgentMail.URL,
                        "beads_db": cfg.Core.BeadsDBPath,
                }).Debug("Configuration loaded successfully")
        }</span>

        // Step 3: Load environment variables from .env
        <span class="cov0" title="0">logger.Debug("Loading environment variables from %s", envPath)
        if err := config.LoadAndValidateEnv(envPath); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to load environment: %v", err)
                fmt.Fprintf(os.Stderr, "Failed to load environment: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Debug("Environment variables loaded successfully")

        // Step 4: Initialize process manager with ~/.asc/pids and ~/.asc/logs
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get home directory: %v", err)
                fmt.Fprintf(os.Stderr, "Failed to get home directory: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">pidsDir := filepath.Join(homeDir, ".asc", "pids")
        logsDir := filepath.Join(homeDir, ".asc", "logs")

        logger.Debug("Initializing process manager with pids=%s, logs=%s", pidsDir, logsDir)
        procManager, err := process.NewManager(pidsDir, logsDir)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize process manager: %v", err)
                fmt.Fprintf(os.Stderr, "Failed to initialize process manager: %v\n", err)
                os.Exit(1)
        }</span>

        // Step 5: Start mcp_agent_mail service
        <span class="cov0" title="0">fmt.Println("Starting mcp_agent_mail service...")
        mcpEnv := buildMCPEnv()
        mcpCmd, mcpArgs := parseCommand(cfg.Services.MCPAgentMail.StartCommand)
        logger.WithFields(logger.Fields{
                "command": mcpCmd,
                "args":    mcpArgs,
        }).Debug("Starting mcp_agent_mail service")
        _, err = procManager.Start("mcp_agent_mail", mcpCmd, mcpArgs, mcpEnv)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start mcp_agent_mail: %v", err)
                fmt.Fprintf(os.Stderr, "Failed to start mcp_agent_mail: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("mcp_agent_mail service started successfully")

        // Step 6: Launch agent processes (handled in subtask 16.2)
        logger.Debug("Launching agent processes")
        if err := launchAgents(cfg, procManager); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to launch agents: %v", err)
                fmt.Fprintf(os.Stderr, "Failed to launch agents: %v\n", err)
                // Clean up: stop mcp_agent_mail
                _ = procManager.StopAll()
                os.Exit(1)
        }</span>

        // Step 7: Initialize and run TUI (handled in subtask 16.3)
        <span class="cov0" title="0">logger.Debug("Initializing TUI dashboard")
        if err := runTUI(cfg, procManager, debugMode); err != nil </span><span class="cov0" title="0">{
                logger.Error("TUI error: %v", err)
                fmt.Fprintf(os.Stderr, "TUI error: %v\n", err)
                // Clean up: stop all processes
                _ = procManager.StopAll()
                os.Exit(1)
        }</span>

        // Clean up on exit
        <span class="cov0" title="0">fmt.Println("\nShutting down agent stack...")
        logger.Info("Shutting down agent stack")
        if err := procManager.StopAll(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error during shutdown: %v", err)
                fmt.Fprintf(os.Stderr, "Error during shutdown: %v\n", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("Agent stack is offline")
        logger.Info("Agent stack is offline")</span>
}

// parseCommand parses a command string into command and args
// For example: "python -m mcp_agent_mail.server" -&gt; ("python", ["-m", "mcp_agent_mail.server"])
func parseCommand(cmdStr string) (string, []string) <span class="cov0" title="0">{
        // Simple space-based parsing
        // For more complex parsing with quotes, we'd need a proper shell parser
        parts := []string{}
        current := ""
        inQuote := false
        
        for _, char := range cmdStr </span><span class="cov0" title="0">{
                if char == '"' || char == '\'' </span><span class="cov0" title="0">{
                        inQuote = !inQuote
                }</span> else<span class="cov0" title="0"> if char == ' ' &amp;&amp; !inQuote </span><span class="cov0" title="0">{
                        if current != "" </span><span class="cov0" title="0">{
                                parts = append(parts, current)
                                current = ""
                        }</span>
                } else<span class="cov0" title="0"> {
                        current += string(char)
                }</span>
        }
        
        <span class="cov0" title="0">if current != "" </span><span class="cov0" title="0">{
                parts = append(parts, current)
        }</span>
        
        <span class="cov0" title="0">if len(parts) == 0 </span><span class="cov0" title="0">{
                return "", []string{}
        }</span>
        
        <span class="cov0" title="0">return parts[0], parts[1:]</span>
}

// buildMCPEnv builds environment variables for the MCP service
func buildMCPEnv() []string <span class="cov0" title="0">{
        // Pass through all current environment variables
        env := os.Environ()
        return env
}</span>

// launchAgents starts all configured agent processes
func launchAgents(cfg *config.Config, procManager process.ProcessManager) error <span class="cov0" title="0">{
        fmt.Printf("Launching %d agent(s)...\n", len(cfg.Agents))
        logger.Info("Launching %d agent(s)", len(cfg.Agents))

        // Iterate through agents in config
        for agentName, agentCfg := range cfg.Agents </span><span class="cov0" title="0">{
                fmt.Printf("  Starting agent: %s (model: %s)...\n", agentName, agentCfg.Model)
                logger.WithFields(logger.Fields{
                        "agent": agentName,
                        "model": agentCfg.Model,
                        "phases": agentCfg.Phases,
                }).Info("Starting agent")

                // Build environment variables for this agent
                agentEnv := buildAgentEnv(agentName, agentCfg, cfg)

                if debugMode </span><span class="cov0" title="0">{
                        logger.WithFields(logger.Fields{
                                "agent": agentName,
                                "env_count": len(agentEnv),
                        }).Debug("Built agent environment variables")
                }</span>

                // Parse command into command and args
                <span class="cov0" title="0">cmd, args := parseCommand(agentCfg.Command)

                logger.WithFields(logger.Fields{
                        "agent": agentName,
                        "command": cmd,
                        "args": args,
                }).Debug("Parsed agent command")

                // Start the agent using process manager
                pid, err := procManager.Start(agentName, cmd, args, agentEnv)
                if err != nil </span><span class="cov0" title="0">{
                        logger.WithFields(logger.Fields{
                                "agent": agentName,
                        }).Error("Failed to start agent: %v", err)
                        return fmt.Errorf("failed to start agent '%s': %w", agentName, err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("  ✓ Agent %s started\n", agentName)
                logger.WithFields(logger.Fields{
                        "agent": agentName,
                        "pid": pid,
                }).Info("Agent started successfully")</span>
        }

        <span class="cov0" title="0">fmt.Println("All agents started successfully")
        logger.Info("All agents started successfully")
        return nil</span>
}

// buildAgentEnv builds environment variables for an agent process
func buildAgentEnv(agentName string, agentCfg config.AgentConfig, cfg *config.Config) []string <span class="cov0" title="0">{
        // Start with all current environment variables (includes API keys from .env)
        env := os.Environ()

        // Add agent-specific environment variables
        env = append(env, fmt.Sprintf("AGENT_NAME=%s", agentName))
        env = append(env, fmt.Sprintf("AGENT_MODEL=%s", agentCfg.Model))
        
        // Convert phases array to comma-separated string
        phases := ""
        for i, phase := range agentCfg.Phases </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        phases += ","
                }</span>
                <span class="cov0" title="0">phases += phase</span>
        }
        <span class="cov0" title="0">env = append(env, fmt.Sprintf("AGENT_PHASES=%s", phases))

        // Add MCP and beads configuration
        env = append(env, fmt.Sprintf("MCP_MAIL_URL=%s", cfg.Services.MCPAgentMail.URL))
        env = append(env, fmt.Sprintf("BEADS_DB_PATH=%s", cfg.Core.BeadsDBPath))

        return env</span>
}

// runTUI initializes and runs the TUI dashboard
func runTUI(cfg *config.Config, procManager process.ProcessManager, debug bool) error <span class="cov0" title="0">{
        // Clear terminal screen
        fmt.Print("\033[H\033[2J")

        logger.Debug("Initializing beads client with path=%s", cfg.Core.BeadsDBPath)
        // Initialize beads client with 5 second refresh interval
        beadsClient := beads.NewClient(cfg.Core.BeadsDBPath, 5*time.Second)

        logger.Debug("Initializing MCP client with url=%s", cfg.Services.MCPAgentMail.URL)
        // Initialize MCP client
        mcpClient := mcp.NewHTTPClient(cfg.Services.MCPAgentMail.URL)

        // Create bubbletea Model with config and clients
        model := tui.NewModel(*cfg, beadsClient, mcpClient, procManager)
        model.SetDebugMode(debug)

        logger.Info("Starting TUI dashboard")
        // Start TUI event loop with tea.NewProgram
        program := tea.NewProgram(
                model,
                tea.WithAltScreen(),       // Use alternate screen buffer
                tea.WithMouseCellMotion(), // Enable mouse support
        )

        // Run the program and handle exit
        finalModel, err := program.Run()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("TUI error: %v", err)
                return fmt.Errorf("TUI error: %w", err)
        }</span>

        // Check if there was an error in the final model state
        <span class="cov0" title="0">if m, ok := finalModel.(tui.Model); ok </span><span class="cov0" title="0">{
                // Cleanup WebSocket and other resources
                m.Cleanup()
                
                if m.GetError() != nil </span><span class="cov0" title="0">{
                        logger.Error("TUI exited with error: %v", m.GetError())
                        return fmt.Errorf("TUI exited with error: %w", m.GetError())
                }</span>
        }

        <span class="cov0" title="0">logger.Info("TUI exited normally")
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
